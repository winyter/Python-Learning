# 0. OOP-Python面向对象
- Python的面向对象
- 面向对象编程
    - 基础
    - 公有私有
    - 继承
    - 组合，Mixin
- 魔法函数
    - 魔法函数概述
    - 构造类魔法函数
    - 运算类魔法函数
    
# 1， 面向对象概述（ObjectOriented. 00)
- OOP思想
    - 接触到任意一个任务，首先想到的是这个任务的构成，是由模型构成
    - 几个名词
        - OO：面向对象
        - OOA：面向对象的分析
        - OOD：面向对象的设计
        - OOI：面向对象的实现
        - OOP：面向对象的编程
        - OOA -> OOD -> OOI：面向对象的实现过程
- 类和对象的概念
    - 类：抽象名词，比如说：学生，是一个抽象的名词，没法实例化
    - 对象：具体的事物，也就是实例
    - 类和对象的关系：
        - 一个是具象的，代表一类事物的某一个个体
        - 一个是抽象的，代表的是一些事物的集合
    - 类中应该具有两个内容：
        - 表明事物的特征，叫做属性 -->> 变量
        - 表明事物的功能或动作，称为成员方法 --->>  函数
# 2、 类的基本实现
- 类的命名
    - 遵守变量命名规范
    - 大驼峰（由一个或多个单词构成，每个单词首字母大写，单词跟单词直接相连）
    - 尽量避开跟系统命名相似的命名
- 类的声明
    - 必须使用class关键字
    - 类由方法和属性构成，其他不允许出现
    - 成员属性定义可以直接使用变量赋值，如果没有值，可以使用None
    - 案例 01.py
- 实例化类
    
        变量 = 类名()  #实例化了一个对象
- 访问对象成员
    - 使用点操作符
        
            obj_name.成员属性名
            obj_name.成员方法
- 可以通过默认内置变量检查类和对象的所有成员
    - 对象所有成员的检查
            
            # dict前后各有两个下划线
            obj_name.__dict__
    - 类的所有成员
    
            # 同样使用dict
            class_name.__dict__
    
# 3、 anconda创建虚拟环境
- anconda主要是一个虚拟环境管理器
- 还是一个安装包管理器
- conda list：显示anconda安装的包
- conda env list：显示anconda的虚拟环境
- conda create -n <env_name> python=3.7：创建python版本为3.7的虚拟环境，env_name为环境名
- 安装完成后，使用source activate <env_name>，激活这个环境，并可以使用conda list查看该环境安装了哪些包
- 随后，就可以在pycharm中，将project关联到这个env上

# 4、类和对象的成员分析
- 类和对象都可以存储成员，成员可以归类所有，也可以归对象所有
- 类存储成员时，使用的是与类关联的一个对象
- 对象存储成员时，是存储在当前对象中
- 对象访问成员时，如果对象中没有该成员，则尝试访问类中的同名成员，如果对象中有此成员，一定会使用对象中的成员
- 创建对象时，类中的成员不会直接复制到对象中，而是得到一个空对象，没有成员
- 通过对象对类中的成员重新赋值或者通过对象添加成员时，对应成员会存放在对象中，而不会修改类成员
- 详见案例 02.py 以及图片，加深理解

# 5、关于self
- self一般放在一个类的一个方法中，充当这个方法的参数，self可以理解成是一个对象的代理人，在对象中调用这个方法时，这个对象会自动传入到当前方法的第一个参数中，也即对象会替代self的位置
- self本身并不是python的关键字，所以，理论上也可以使用其他字符来充当这个代理，但是不建议
- 类的方法中，有self形参的方法称之为非绑定类的方法，可以通过对象访问（因为这个self本来就是对象的代理），而没有self的是绑定类的方法，只能通过类去访问
- 类的方法可以调用类的成员，不管是非绑定类的方法还是绑定类的方法
- 详见案例 02.py
- 鸭子模型：Python中，self不仅可以是对象的代理，也可以是类的代理，也就是说，在Python中，不仅对象可以作为参数传入方法，类也可以作为参数传入方法，但是，需要注意，实际上并不是类被传入了方法，而是类的默认实例被传入了方法，理解鸭子模型一定要记住Python中的类都会有一个与其同名的实例对象
- 详见案例 03.py

# 6、面向对象的三大特性
- 封装
- 继承
- 多态

## 6.1、封装
- 封装就是对对象内的成员进行访问限制
- 封装的三个级别：
    - 公开：public
    - 受保护的：protected
    - 私有：private
    - public、protected、private在Python中，不是关键字，Python只是使用了这种思想，真正的使用，另有方法
- 判断对象的位置
    - 对象内部
    - 对象外部
    - 子类中
- 私有
    - 私有成员是最高级别的封装，只能在当前类或对象中访问
    - 使用方法：在成员名前面加上两个下划线 __
    
            class Person():
                #name是公有成员
                name = "winyter"
                #__age是私有成员
                __age = 18
    -Python的私有并不是真正的私有，而是采用一种名叫：name mangling的改名策略，将这个成员的名称进行了改变，从而达到保护的目的，实际上想访问仍然是有方法的：
        - 该改名策略是固定的格式：_<classname>__<attributename>，所以，直接使用这个格式，就能访问到私有成员
    - 详见案例 04.py
- 受保护的 protected
    - 受保护的封装是将成员进行一定级别的封装，在类或子类中都可以访问，但是在外部不能访问
    - 封装方法：在成员前面加上一个下划线
    - 受保护的封装依然使用name mangling改名策略对成员进行一定的保护
- 公开
    - 公共的封装实际上没有对成员做任何操作，任何地方都可以访问
    
## 6.2、继承
- 继承就是一个类可以获得另外一个类的成员属性和成员方法
- 作用：减少代码，增加代码的复用功能，同时可以设置类与类之间的关系
- 继承与被继承的概念：
    - 被继承的类叫父类，也叫基类、超类
    - 用于继承的类，叫子类，也叫派生类
    - 继承与被继承一定存在一个 is-a 关系，即继承类一定要是被继承类的子集，比如：老师这个类属于人这个类，老师是人的子集
- 继承的语法，参见 05.py
- 继承的特征
    - 所有的类都继承于object类，即所有类都是object的子类
    - 子类一旦继承父类，则可以调用父类中，除私有成员外的所有成员
    - 子类继承父类后，并没有将父类的值赋到子类中，而是直接引用父类中的成员来进行调用
    - 子类可以定义自己独享的属性和方法
    - 子类中定义的成员如果与父类中的成员名一样，则优先使用子类中的成员
    - 子类如果想扩充父类中的方法，可以在定义新方法的同时，访问父类成员来进行代码的重用，可以使用 <父类名>.<父类成员名> 的格式来调用父类成员，也可以使用 super().<父类成员名> 的格式来调用
    - 详见案例 06.py
- 继承中，成员的查找顺序问题
    - 优先查找自己类中的成员（包括构造函数中）
    - 查到了则不调用父类
    - 没有查到的话，会调用父类
    - 详见案例 07.py
- 构造函数
    - 是一个特殊的函数，在类的实例化之前就会被调用执行
    - 构造函数在每次实例化类之前就会被调用执行，需要注意：实例化是指诸如：创建一个对象：x = X()的情况，而不是x.M()这种仅仅是调用父类的情况，如果对象调用父类中的一个成员，是不会触发构造函数的
    - 如果子类中没有定义构造函数，那么在实例化子类时，会自动调用父类中构造函数，此时，需要注意，调用子类时需要按照父类构造函数的参数，来构造参数，否则会报参数传递数量不正确的错误
    - 构造函数建议一定要有，如果没有，则自动向上查找，按照MRO顺序，直到找到为止
    - 详见案例 07.py
- super()
    - super不是关键字，也不是方法，是一个类
    - super的作用是获取 MRO (MethodResolustionOrder) 列表中的第一个父类
    - MRO：详细了解上网查，可以简单的理解就是把存储类的"家族图谱"
    - super与父类没有实质性的关系，但通过super可以调用到父类
- 单继承与多继承
    - 单继承：每个类只能继承一个类
    - 多继承：每个类允许继承多个类
- 单继承与多继承的优缺点
    - 单继承：
        - 优点：传承有序、逻辑清晰、语法简单、隐患少
        - 缺点：功能不能无限拓展，只能在当前唯一的继承链中扩展
    - 多继承：
        - 优点：类的功能扩展方便
        - 缺点：继承关系混乱
        
- 菱形继承\钻石继承问题
    - 多个子类继承自同一个父类，这些子类又被同一个类继承，于是继承关系就像一个菱形
    - 关于多继承的MRO：
        - MRO就是多继承中，用于保存继承顺序的一个列表
        - Python本身采用C3算法来对多继承的菱形继承进行计算
        - MRO列表计算原则：
            - 子类永远在父类前面
            - 如果有多个父类，则根据继承语法中，括号内书写的顺序来存放
            - 如果多个父类继承了同一个类，那么，孙子类只会选取括号内第一个父类继承的父类
            
## 3.3 多态
- 多态就是同一个对象在不同情况下有不同的状态出现
- 多态在Python中不是语法，而是一种设计思想
- 多态性：一种调用方式，不同的执行结果
- 多态：同一个事物的多种形态，例如：动物分为人类、狗类、猪类

- Mixin设计模式
    - Python中，只要采用多继承的方式来对类进行扩展
    - 与传统的多继承相比，Mixin模式强调最多只允许有一个真正意义上的父类，其他的所有继承类，均仅仅是一个功能的扩展类
    - 而传统的多继承更加强调层级，比如，老师、学生是人类，那么我的代码中，老师和学生就一定要继承人这个类，然后助教这个类再继承自老师和学生类，在使用了Mixin模式后，我们不强调这种层级关系，助教类仅需要使用老师类和学生类中的功能，那么我可以把老师和学生类仅看做是一个功能类，在需要时我进行继承即可；
    
- 我们使用多继承语法来实现Mixin
- 使用Mixin的时候需要格外注意：
    - 首先他必须表示单一的一个功能，而不是某个物品
    - 职责必须单一，如果有多个功能，则需要写多个Mixin
    - Mixin不能依赖于子类实现
    - 子类即使没有继承这个Mixin类，也照样能够工作，只是缺少了某个功能

- 优点：
    - 使用Mixin可以在不对类做任何修改的情况下，扩充功能
    - 可以方便的组织和维护不同的功能组件的划分
    - 可以根据需要任意调整功能类的组合
    - 可以避免创建多个新类，导致类继承的混乱
- Mixin的案例详见 08.py

# 4、继承的相关类
- issubclass:检测一个类是否是另一个类的子类

        # 语法
        issubclass(<子类名>.<父类名>)
        
- isinstance：检测一个对象是否是一个类的实例

        isinstance(<对象名>.<类名>
        
- hasattr：检测一个对象是否有成员 xxx
- getattr：获取成员值
- setattr：设置成员值
- delattr：删除成员值
- dir：获取对象的成员列表

# 5、类的成员描述符
- 类的成员描述符是为了在类中对类的成员属性进行操作而创建的一种方式
    - get：获取属性时的操作，即在调用成员，读取属性时的操作
    - set：修改或添加属性时的操作，即对成员添加或修改属性时的操作
    - delete：删除属性时的操作，即删除成员属性时的操作
- 如果想使用成员描述符，有三种方式：
    - 通过类来实现
    - 通过属性修饰符来实现
    - 通过porperty函数实现
            
            首先定义 get、set、del 时的方法
            property(<get方法名>, <set方法名>, <delete方法名>, doc)
    - 详见案例09.py
- 实际上，成员描述符可以理解为：不使用系统默认的读取、赋值、删除操作，而是自定义一套读写删的操作
    
# 6、类的内置属性
        
        __dict__:以字典的方式显示类的成员的组成
        __doc__:获取类的文档信息
        __name__:获取类的名称，如果在模块中使用，获取模块的名称
        __bases__:获取某个类的所有父类，以元组的形式显示
        
# 7、类的常用魔术方法
- 魔术方法就是不需要人为调用的方法，基本是在特定的时刻自动触发
- 魔术方法的统一特征：方法名被前后各两个下划线包裹
- 操作类
    - `__init__`：当类被调用时触发，可以理解为构造函数
    - `__new__`：对象实例化方法，此函数比较特殊，一般不需要使用
    - `__call__`：对象当成函数使用时触发
    - `__str__`：当对象被当成字符串使用的时候触发
    - `__repr__`：返回字符串，跟__str__有细微区别，具体百度
- 描述符相关
    - `__set__`
    - `__get__`
    - `__delete__`
- 属性操作相关
    - `__getattr__`：访问一个不存在的对象时触发
    - `__setattr__`：对成员属性进行设置的时候触发
        - 参数：
            - self用来获取当前对象
            - 被设置的属性名称，以字符串形式出现
            - 需要对属性名称设置的值
        - 作用：进行属性设置的时候进行验证或修改
        - 注意：在该方法中不能对属性直接进行赋值操作，否则死循环
        - 解决方法：对父类中的该属性进行赋值,使用super()来实现调用父类
- 运算类相关
    - `__gt__`：进行大于判断时触发
        - 参数：
            - self
            - 第二个参数是第二个对象
            - 返回值可以是任意值，但推荐布尔值
        - 案例详见 10.py
        
# 8、类和对象的三种方法
- 实例方法
    - 需要实例化对象才能使用，使用过程中可能需要借着对象的其他对象的方法完成
- 静态方法
    - 不需要实例化，直接通过类访问
- 类方法
    - 不需要实例化
- 案例详见11.py
- 三种方法的区别

# 9、抽象类
- 抽象方法：没有具体实现内容的方法称为抽象方法
- 抽象方法的主要意义是规范子类的行为和接口
- 抽象类的使用需要借助模块abc

        import abc
        
- 抽象类：包含抽象方法的类叫做抽象类，通常称为ABC类
- 抽象类的使用
    - 抽象类可以包含抽象方法，也可以包含具体方法
    - 抽象类中可以有方法也可以有属性
    - 抽象类不允许实例化
    - 抽象类必须继承才能使用，且，子类中，必须实现所有继承的抽象方法
    - 如果子类没有实现全部的抽象方法，则子类也不能实例化
    - 抽象类的主要作用是指定类的标准，以便于开发时有统一规范
- 详见案例 12.py